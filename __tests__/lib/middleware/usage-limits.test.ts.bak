/**
 * Usage Limits Middleware Tests (TDD)
 * Sprint 5 Phase 2 - Task #6
 *
 * Tests tier-based usage limits:
 * - FREE: 10 tournaments, 5 teams, 2 bookings
 * - PRO: 50 tournaments, 20 teams, 10 bookings
 * - DUAL/PREMIUM/CLUB: unlimited
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  checkUsageLimit,
  canCreateTournament,
  canCreateTeam,
  canCreateBooking,
  incrementUsage,
  resetMonthlyUsage,
  type UsageLimitResult,
} from '@/lib/middleware/usage-limits';
import { createClient } from '@/lib/supabase/server';

// Mock Supabase client
vi.mock('@/lib/supabase/server', () => ({
  createClient: vi.fn(),
}));

describe('Usage Limits Middleware', () => {
  const mockUserId = 'user-123';
  const mockSupabase = {
    from: vi.fn(),
    auth: {
      getUser: vi.fn(),
    },
  };

  beforeEach(() => {
    vi.clearAllMocks();
    (createClient as any).mockResolvedValue(mockSupabase);
  });

  describe('FREE tier limits', () => {
    beforeEach(() => {
      // Mock FREE subscription
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'free', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        return { select: () => ({ eq: () => ({}) }) };
      });
    });

    it('should allow tournament creation when under limit (0/10)', async () => {
      // Mock usage: 0 tournaments created
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'free', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            select: vi.fn().mockReturnThis(),
            eq: vi.fn().mockReturnThis(),
            gte: vi.fn().mockResolvedValue({ count: 0, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(10);
      expect(result.limit).toBe(10);
    });

    it('should allow tournament creation when at 9/10 limit', async () => {
      // Mock usage: 9 tournaments created
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'free', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            select: vi.fn().mockReturnThis(),
            eq: vi.fn().mockReturnThis(),
            gte: vi.fn().mockResolvedValue({ count: 9, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(1);
      expect(result.limit).toBe(10);
    });

    it('should deny tournament creation when exactly at limit (10/10)', async () => {
      // Mock usage: 10 tournaments created (limit reached)
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'free', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            count: vi.fn().mockResolvedValue({ count: 10, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      expect(result.allowed).toBe(false);
      expect(result.remaining).toBe(0);
      expect(result.limit).toBe(10);
    });

    it('should allow 5 teams creation for FREE tier', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'free', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            count: vi.fn().mockResolvedValue({ count: 3, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateTeam(mockUserId);

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(2);
      expect(result.limit).toBe(5);
    });

    it('should allow 2 bookings for FREE tier', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'free', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            count: vi.fn().mockResolvedValue({ count: 0, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateBooking(mockUserId);

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(2);
      expect(result.limit).toBe(2);
    });

    it('should deny booking when limit reached (2/2)', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'free', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            count: vi.fn().mockResolvedValue({ count: 2, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateBooking(mockUserId);

      expect(result.allowed).toBe(false);
      expect(result.remaining).toBe(0);
      expect(result.limit).toBe(2);
    });
  });

  describe('PRO tier limits', () => {
    beforeEach(() => {
      // Mock PRO subscription
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'pro', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        return {};
      });
    });

    it('should allow 50 tournaments for PRO tier', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'pro', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            count: vi.fn().mockResolvedValue({ count: 25, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(25);
      expect(result.limit).toBe(50);
    });

    it('should deny tournament when at PRO limit (50/50)', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'pro', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            count: vi.fn().mockResolvedValue({ count: 50, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      expect(result.allowed).toBe(false);
      expect(result.remaining).toBe(0);
      expect(result.limit).toBe(50);
    });

    it('should allow 20 teams for PRO tier', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'pro', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            count: vi.fn().mockResolvedValue({ count: 10, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateTeam(mockUserId);

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(10);
      expect(result.limit).toBe(20);
    });

    it('should allow 10 bookings for PRO tier', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'pro', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            count: vi.fn().mockResolvedValue({ count: 7, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateBooking(mockUserId);

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(3);
      expect(result.limit).toBe(10);
    });
  });

  describe('PREMIUM/DUAL/CLUB tier - unlimited', () => {
    it.each(['premium', 'dual', 'club'])(
      'should allow unlimited tournaments for %s tier',
      async (plan) => {
        mockSupabase.from.mockImplementation((table: string) => {
          if (table === 'subscription') {
            return {
              select: () => ({
                eq: () => ({
                  single: vi.fn().mockResolvedValue({
                    data: { plan, status: 'active' },
                    error: null,
                  }),
                }),
              }),
            };
          }
          if (table === 'usage_log') {
            // Simulate 1000 tournaments already created
            return {
              count: vi.fn().mockResolvedValue({ count: 1000, error: null }),
            };
          }
          return {};
        });

        const result = await canCreateTournament(mockUserId);

        expect(result.allowed).toBe(true);
        expect(result.remaining).toBe(-1); // -1 indicates unlimited
        expect(result.limit).toBe(-1);
      }
    );

    it.each(['premium', 'dual', 'club'])(
      'should allow unlimited teams for %s tier',
      async (plan) => {
        mockSupabase.from.mockImplementation((table: string) => {
          if (table === 'subscription') {
            return {
              select: () => ({
                eq: () => ({
                  single: vi.fn().mockResolvedValue({
                    data: { plan, status: 'active' },
                    error: null,
                  }),
                }),
              }),
            };
          }
          return {};
        });

        const result = await canCreateTeam(mockUserId);

        expect(result.allowed).toBe(true);
        expect(result.remaining).toBe(-1);
        expect(result.limit).toBe(-1);
      }
    );
  });

  describe('Monthly usage reset', () => {
    it('should only count current month usage', async () => {
      const now = new Date();
      const periodStart = new Date(now.getFullYear(), now.getMonth(), 1);

      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'free', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            select: vi.fn().mockReturnThis(),
            eq: vi.fn().mockReturnThis(),
            gte: vi.fn((field: string, value: string) => {
              // Verify we're filtering by current period
              expect(field).toBe('timestamp');
              expect(new Date(value).getMonth()).toBe(periodStart.getMonth());
              return {
                count: vi.fn().mockResolvedValue({ count: 3, error: null }),
              };
            }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(7); // 10 - 3
    });

    it('should reset usage at beginning of new month', async () => {
      // Simulate new month scenario
      const result = await resetMonthlyUsage(mockUserId);

      expect(result.success).toBe(true);
    });
  });

  describe('Usage increment', () => {
    it('should log tournament creation in usage_log', async () => {
      const insertMock = vi.fn().mockResolvedValue({ error: null });
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'usage_log') {
          return {
            insert: insertMock,
          };
        }
        return {};
      });

      await incrementUsage(mockUserId, 'tournament_created');

      expect(insertMock).toHaveBeenCalledWith(
        expect.objectContaining({
          user_id: mockUserId,
          feature: 'tournament_created',
          action: 'create',
        })
      );
    });

    it('should log team creation in usage_log', async () => {
      const insertMock = vi.fn().mockResolvedValue({ error: null });
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'usage_log') {
          return {
            insert: insertMock,
          };
        }
        return {};
      });

      await incrementUsage(mockUserId, 'team_created');

      expect(insertMock).toHaveBeenCalledWith(
        expect.objectContaining({
          user_id: mockUserId,
          feature: 'team_created',
          action: 'create',
        })
      );
    });

    it('should log booking creation in usage_log', async () => {
      const insertMock = vi.fn().mockResolvedValue({ error: null });
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'usage_log') {
          return {
            insert: insertMock,
          };
        }
        return {};
      });

      await incrementUsage(mockUserId, 'booking_created');

      expect(insertMock).toHaveBeenCalledWith(
        expect.objectContaining({
          user_id: mockUserId,
          feature: 'booking_created',
          action: 'create',
        })
      );
    });
  });

  describe('Error handling', () => {
    it('should deny access if subscription fetch fails', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: null,
                  error: new Error('Database error'),
                }),
              }),
            }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      expect(result.allowed).toBe(false);
      expect(result.error).toBeDefined();
    });

    it('should deny access if usage_log fetch fails', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'free', status: 'active' },
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            count: vi.fn().mockResolvedValue({ count: null, error: new Error('DB error') }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      expect(result.allowed).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Edge cases', () => {
    it('should handle missing subscription (default to FREE)', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: null, // No subscription found
                  error: null,
                }),
              }),
            }),
          };
        }
        if (table === 'usage_log') {
          return {
            count: vi.fn().mockResolvedValue({ count: 0, error: null }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      // Should default to FREE tier limits
      expect(result.limit).toBe(10);
    });

    it('should handle suspended subscription (deny access)', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'pro', status: 'suspended' },
                  error: null,
                }),
              }),
            }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      expect(result.allowed).toBe(false);
      expect(result.error).toContain('suspended');
    });

    it('should handle past_due subscription (deny access)', async () => {
      mockSupabase.from.mockImplementation((table: string) => {
        if (table === 'subscription') {
          return {
            select: () => ({
              eq: () => ({
                single: vi.fn().mockResolvedValue({
                  data: { plan: 'pro', status: 'past_due' },
                  error: null,
                }),
              }),
            }),
          };
        }
        return {};
      });

      const result = await canCreateTournament(mockUserId);

      expect(result.allowed).toBe(false);
      expect(result.error).toContain('past_due');
    });
  });
});
