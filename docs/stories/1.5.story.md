# Story 1.5: PayPal Webhook Handler

**Epic**: 1 - PayPal Integration
**Story ID**: 1.5
**Status**: Draft
**Priority**: Critical
**Estimated Effort**: 5-6 hours
**Dependencies**: Story 1.2 (Database schema), Story 1.1 (PayPal config)

---

## üìñ User Story

**As a** system
**I want** to receive and process PayPal webhook events
**So that** subscription states stay synchronized automatically

---

## ‚úÖ Acceptance Criteria

1. POST /api/paypal/webhook endpoint created
2. Verifies PayPal webhook signature
3. Logs all events to paypal_webhook_events table
4. Processes BILLING.SUBSCRIPTION.* events
5. Updates subscriptions table based on events
6. Handles idempotency (duplicate events)
7. Returns 200 for valid events
8. Returns 400 for invalid signatures
9. Async processing doesn't block response

---

## üîß Dev Notes

### Webhook Events to Handle

```typescript
type PayPalWebhookEvent =
  | 'BILLING.SUBSCRIPTION.CREATED'
  | 'BILLING.SUBSCRIPTION.ACTIVATED'
  | 'BILLING.SUBSCRIPTION.UPDATED'
  | 'BILLING.SUBSCRIPTION.CANCELLED'
  | 'BILLING.SUBSCRIPTION.SUSPENDED'
  | 'BILLING.SUBSCRIPTION.EXPIRED'
  | 'BILLING.SUBSCRIPTION.PAYMENT.FAILED'
  | 'PAYMENT.SALE.COMPLETED'
  | 'PAYMENT.SALE.REFUNDED';
```

[Source: SPRINT_5_PRD.md Phase 1.5 + PayPal docs]

### Implementation

**File**: `src/app/api/paypal/webhook/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { verifyPayPalWebhook } from '@/lib/paypal/webhook-verify';

export async function POST(request: NextRequest) {
  const supabase = await createClient();

  try {
    // 1. Get raw body and headers
    const body = await request.text();
    const headers = {
      'paypal-transmission-id': request.headers.get('paypal-transmission-id'),
      'paypal-transmission-time': request.headers.get('paypal-transmission-time'),
      'paypal-transmission-sig': request.headers.get('paypal-transmission-sig'),
      'paypal-cert-url': request.headers.get('paypal-cert-url'),
      'paypal-auth-algo': request.headers.get('paypal-auth-algo'),
    };

    // 2. Verify signature (CRITICAL for security)
    const isValid = await verifyPayPalWebhook(body, headers);
    if (!isValid) {
      console.error('Invalid PayPal webhook signature');
      return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });
    }

    // 3. Parse event
    const event = JSON.parse(body);

    // 4. Check idempotency (prevent duplicate processing)
    const { data: existing } = await supabase
      .from('paypal_webhook_events')
      .select('id')
      .eq('event_id', event.id)
      .single();

    if (existing) {
      console.log(`Duplicate event ${event.id}, skipping`);
      return NextResponse.json({ received: true }, { status: 200 });
    }

    // 5. Log event
    await supabase.from('paypal_webhook_events').insert({
      event_id: event.id,
      event_type: event.event_type,
      resource_type: event.resource_type,
      payload: event,
      processed: false,
    });

    // 6. Process event asynchronously
    await processWebhookEvent(event, supabase);

    // 7. Mark as processed
    await supabase
      .from('paypal_webhook_events')
      .update({ processed: true, processed_at: new Date().toISOString() })
      .eq('event_id', event.id);

    return NextResponse.json({ received: true }, { status: 200 });

  } catch (error) {
    console.error('Webhook processing error:', error);
    // Log error but return 200 to prevent PayPal retries
    await supabase.from('paypal_webhook_events').update({
      error: error instanceof Error ? error.message : 'Unknown error',
    }).eq('event_id', event.id);

    return NextResponse.json({ received: true }, { status: 200 });
  }
}

async function processWebhookEvent(event: any, supabase: any) {
  const eventType = event.event_type;
  const resource = event.resource;

  switch (eventType) {
    case 'BILLING.SUBSCRIPTION.ACTIVATED':
      await supabase
        .from('subscriptions')
        .update({
          status: 'active',
          paypal_customer_id: resource.subscriber?.payer_id,
          current_period_start: resource.billing_info?.last_payment?.time,
          current_period_end: resource.billing_info?.next_billing_time,
        })
        .eq('paypal_subscription_id', resource.id);
      break;

    case 'BILLING.SUBSCRIPTION.CANCELLED':
      await supabase
        .from('subscriptions')
        .update({
          status: 'canceled',
          canceled_at: new Date().toISOString(),
        })
        .eq('paypal_subscription_id', resource.id);
      break;

    case 'BILLING.SUBSCRIPTION.SUSPENDED':
      await supabase
        .from('subscriptions')
        .update({ status: 'suspended' })
        .eq('paypal_subscription_id', resource.id);
      break;

    case 'PAYMENT.SALE.COMPLETED':
      // Log payment
      await supabase.from('payments').insert({
        user_id: resource.custom_id, // Need to pass user_id in subscription
        paypal_payment_id: resource.id,
        amount: Math.round(parseFloat(resource.amount.total) * 100),
        currency: resource.amount.currency,
        status: 'completed',
        completed_at: new Date().toISOString(),
      });
      break;
  }
}
```

[Source: Existing webhook pattern in src/app/api/paypal/webhook/route.ts]

---

## üìã Tasks / Subtasks

### Task 1: Implement Webhook Signature Verification (AC: 2, 8)
1. Create `src/lib/paypal/webhook-verify.ts`
2. Implement `verifyPayPalWebhook()` function
3. Use PayPal SDK verification methods
4. Return boolean (valid/invalid)

### Task 2: Create Webhook Route (AC: 1)
1. Create `src/app/api/paypal/webhook/route.ts`
2. Implement POST handler
3. Extract headers and body

### Task 3: Implement Idempotency Check (AC: 6)
1. Query paypal_webhook_events by event_id
2. Return early if already processed
3. Log duplicate event

### Task 4: Log Webhook Event (AC: 3)
1. Insert event into paypal_webhook_events
2. Store full payload as JSONB
3. Set processed = false initially

### Task 5: Process Subscription Events (AC: 4, 5)
1. Implement event processor function
2. Handle ACTIVATED event ‚Üí update status
3. Handle CANCELLED event ‚Üí update status
4. Handle SUSPENDED event ‚Üí update status
5. Handle PAYMENT.SALE.COMPLETED ‚Üí log payment

### Task 6: Mark Event as Processed (AC: 9)
1. Update paypal_webhook_events
2. Set processed = true
3. Set processed_at timestamp

### Task 7: Error Handling (AC: 5, 7)
1. Wrap in try-catch
2. Log errors to webhook_events table
3. Return 200 (prevent PayPal retries)
4. Alert on critical errors

### Task 8: Unit Tests (AC: 1-9)
1. Create `__tests__/api/paypal/webhook.test.ts`
2. Test: Valid signature accepted
3. Test: Invalid signature rejected
4. Test: Idempotency works
5. Test: Events processed correctly
6. Test: Error handling
7. Mock PayPal SDK
8. Run tests

---

## üß™ Testing Strategy

**Unit Tests**: Mock PayPal SDK and Supabase
**Integration Test**: Use PayPal Sandbox webhook simulator
**Manual Test**: Trigger test event from PayPal dashboard

---

## üìù Definition of Done

- [ ] Webhook endpoint implemented
- [ ] Signature verification working
- [ ] All events logged
- [ ] Subscription status synchronized
- [ ] Idempotency implemented
- [ ] Error handling robust
- [ ] Unit tests passing
- [ ] Integration test successful
- [ ] Deployed to Vercel
- [ ] Webhook URL registered in PayPal

---

**Created**: 2025-10-18
**Source**: Epic 1, SPRINT_5_PRD.md Phase 1.5
