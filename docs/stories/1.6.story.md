# Story 1.6: Usage Limits Middleware

**Epic**: 1 - PayPal Integration
**Story ID**: 1.6
**Status**: Draft
**Priority**: High
**Estimated Effort**: 4-5 hours
**Dependencies**: Story 1.2 (Database), Story 1.3 (Plans API)

---

## ðŸ“– User Story

**As a** system
**I want** to enforce feature usage limits based on subscription tier
**So that** free users have restricted access and paid users get full access

---

## âœ… Acceptance Criteria

1. Usage checking function implemented for all features
2. Tracks usage in usage_logs table
3. Returns usage status (allowed/denied, remaining count)
4. Integrates with existing recommendation/tournament APIs
5. Free tier limits enforced (2 tournaments, 3 auto-match/week, 10 recommendations/day, 1 travel plan)
6. Pro tier limits enforced (unlimited tournaments, 20 auto-match/week, 100 recommendations/day)
7. Premium/Club unlimited access
8. Performance: <10ms overhead per check

---

## ðŸ”§ Dev Notes

### Implementation

**File**: `src/lib/middleware/usage-enforcement.ts`

```typescript
import { createClient } from '@/lib/supabase/server';
import { SUBSCRIPTION_PLANS } from '@/lib/paypal/plans';

type Feature = 'tournament' | 'auto_match' | 'recommendation' | 'travel_plan';

interface UsageCheckResult {
  allowed: boolean;
  remaining: number | 'unlimited';
  limit: number | 'unlimited';
  current_usage: number;
}

export async function checkUsageLimit(
  userId: string,
  feature: Feature
): Promise<UsageCheckResult> {
  const supabase = await createClient();

  // 1. Get user's subscription
  const { data: subscription } = await supabase
    .from('subscriptions')
    .select('plan_id, status')
    .eq('user_id', userId)
    .eq('status', 'active')
    .single();

  const plan = SUBSCRIPTION_PLANS.find(p => p.id === (subscription?.plan_id || 'free'));
  const limit = plan?.features[feature as keyof typeof plan.features];

  // 2. If unlimited, allow immediately
  if (limit === 'unlimited') {
    return {
      allowed: true,
      remaining: 'unlimited',
      limit: 'unlimited',
      current_usage: 0,
    };
  }

  // 3. Get current usage
  const timeframe = getTimeframe(feature);
  const { count } = await supabase
    .from('usage_logs')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .eq('feature', feature)
    .gte('timestamp', timeframe);

  const currentUsage = count || 0;
  const numericLimit = typeof limit === 'number' ? limit : 0;

  // 4. Check if allowed
  const allowed = currentUsage < numericLimit;
  const remaining = Math.max(0, numericLimit - currentUsage);

  return {
    allowed,
    remaining,
    limit: numericLimit,
    current_usage: currentUsage,
  };
}

function getTimeframe(feature: Feature): string {
  const now = new Date();

  switch (feature) {
    case 'auto_match':
      // Weekly limit - check last 7 days
      return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString();
    case 'recommendation':
      // Daily limit - check last 24 hours
      return new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString();
    default:
      // Monthly limit - check last 30 days
      return new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString();
  }
}

export async function logUsage(
  userId: string,
  feature: Feature,
  action: string,
  metadata?: Record<string, any>
): Promise<void> {
  const supabase = await createClient();

  await supabase.from('usage_logs').insert({
    user_id: userId,
    feature,
    action,
    metadata,
    timestamp: new Date().toISOString(),
  });
}
```

[Source: Existing middleware pattern in src/lib/middleware/usage-limits.ts]

---

## ðŸ“‹ Tasks / Subtasks

### Task 1: Create Middleware File (AC: 1)
1. Create `src/lib/middleware/usage-enforcement.ts`
2. Define Feature type
3. Define UsageCheckResult interface

### Task 2: Implement checkUsageLimit() (AC: 1-7)
1. Get user subscription
2. Get plan limits from config
3. Handle unlimited case
4. Query usage_logs for timeframe
5. Calculate remaining
6. Return result object

### Task 3: Implement getTimeframe() Helper (AC: 5, 6)
1. Handle weekly features (auto_match)
2. Handle daily features (recommendation)
3. Handle monthly features (tournament, travel_plan)

### Task 4: Implement logUsage() (AC: 2)
1. Insert into usage_logs table
2. Include metadata
3. Handle errors gracefully

### Task 5: Integrate with Recommendations API (AC: 4)
1. Open `src/app/api/recommendations/route.ts`
2. Add usage check before processing
3. Return 429 if limit exceeded
4. Log usage after successful recommendation
5. Test integration

### Task 6: Unit Tests (AC: 1-8)
1. Create `__tests__/lib/middleware/usage-enforcement.test.ts`
2. Test: Free tier limits enforced
3. Test: Pro tier limits enforced
4. Test: Unlimited access for Premium/Club
5. Test: Timeframe calculations
6. Test: Usage logging
7. Test: Performance (<10ms)
8. Run tests

---

## ðŸ§ª Testing Strategy

**Unit Tests**: Mock Supabase, test limit logic
**Integration Tests**: Real API calls with usage checks
**Performance Test**: Measure overhead with benchmarks

---

## ðŸ“ Definition of Done

- [ ] Middleware implemented
- [ ] All features have usage checking
- [ ] Limits enforced correctly per tier
- [ ] Usage logging working
- [ ] Integrated with at least 1 API
- [ ] Performance target met (<10ms)
- [ ] Unit tests passing
- [ ] Integration tests successful
- [ ] Code committed

---

**Created**: 2025-10-18
**Source**: Epic 1, SPRINT_5_PRD.md Phase 1.6
